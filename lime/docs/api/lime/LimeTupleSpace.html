<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Jan 07 15:48:31 EST 2002 -->
<TITLE>
'lime 1.0 API': Class  LimeTupleSpace
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LimeTupleSpace.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../lime/LimeTupleID.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../lime/LocalizedReaction.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LimeTupleSpace.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
lime</FONT>
<BR>
Class  LimeTupleSpace</H2>
<PRE>
java.lang.Object
  |
  +--<B>lime.LimeTupleSpace</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public class <B>LimeTupleSpace</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>

<P>
<P>This class, <code>LimeTupleSpace</code>, provides an implementation for
the Interface Tuple Space (ITS), the most basic component of a Lime-based
application.  It is through the ITS that a process interacts with the rest
of the world.  In addition to the conventional operations to write a tuple
to the tuple space (<code>out</code>) and read or withdraw a matching
tuple from the tuple space (<code>rd, in</code>), Lime provides location
enhanced operations, reactivity, and operations to set a tuple space's
sharing properties (shared or private)
<P>
<DL>
<DT><B>Version: </B><DD>1.0 alpha</DD>
<DT><B>Author: </B><DD><a href="mailto:murphy@cs.rochester.edu">Amy L. Murphy</a>, <a href="mailto:picco@elet.polimi.it">Gian Pietro Picco</a></DD>
<DT><B>See Also: </B><DD><A HREF="../lime/StationaryAgent.html"><CODE>StationaryAgent</CODE></A>, 
<A HREF="../lime/Location.html"><CODE>Location</CODE></A>, 
<A HREF="../lime/Reaction.html"><CODE>Reaction</CODE></A>, 
<A HREF="../lime/ReactionListener.html"><CODE>ReactionListener</CODE></A>, <A HREF="../serialized-form.html#lime.LimeTupleSpace">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#DEFAULT">DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default name for tuple spaces.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#SYSTEM">SYSTEM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The name of the Lime system tuple space.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#LimeTupleSpace()">LimeTupleSpace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a default Lime tuple space, named DEFAULT.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#LimeTupleSpace(java.lang.String)">LimeTupleSpace</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a named Lime tuple space.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#addStrongReaction(lime.LocalizedReaction[])">addStrongReaction</A></B>(<A HREF="../lime/LocalizedReaction.html">LocalizedReaction</A>[]&nbsp;reactions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a group of reactions with the Lime tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#addWeakReaction(lime.Reaction[])">addWeakReaction</A></B>(<A HREF="../lime/Reaction.html">Reaction</A>[]&nbsp;reactions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers a group of weak reactions with the Lime tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the name of the Lime tuple space as given by the user.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#getRegisteredReactions()">getRegisteredReactions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the reactions registered on this Lime tuple space, i.e., all
 those registered by the agent owning this Lime tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#in(lights.interfaces.ITuple)">in</A></B>(lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a tuple that matches a given template, and removes it from the
tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#in(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">in</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
   <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
   lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a tuple that matches a given template, and removes it from the
tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#ing(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">ing</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
    lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve all tuples that match a pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#inp(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">inp</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
    lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a tuple that matches a given template, and removes it from the
tuple space, or returns <code>null</code> if no matching tuple
exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#isOwner()">isOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return <code>true</code> if the thread calling this method is the
<code>ILimeAgentAgent</code> object that owns this Lime tuple space
object, <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#isRegisteredReaction(lime.RegisteredReaction)">isRegisteredReaction</A></B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>&nbsp;reaction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether a given reaction is still registered.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#isShared()">isShared</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if this tuple space is currently shared,
 <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#out(lime.AgentLocation, lights.interfaces.ITuple)">out</A></B>(<A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
    lights.interfaces.ITuple&nbsp;tuple)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts a tuple in the shared tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#out(lights.interfaces.ITuple)">out</A></B>(lights.interfaces.ITuple&nbsp;tuple)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts a tuple in the shared tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#outg(lime.AgentLocation, lights.interfaces.ITuple[])">outg</A></B>(<A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
     lights.interfaces.ITuple[]&nbsp;tuples)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write a set of tuples to the tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#print()">print</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints the contents of the tuple space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#rd(lights.interfaces.ITuple)">rd</A></B>(lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a copy of a tuple that matches a given template.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#rd(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">rd</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
   <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
   lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a copy of a tuple that matches a given template.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#rdg(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">rdg</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
    lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy all tuples that match a pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;lights.interfaces.ITuple</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#rdp(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)">rdp</A></B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
    lights.interfaces.ITuple&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a copy of a tuple that matches a given template, or returns
<code>null</code> if no matching tuple exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#removeStrongReaction(lime.RegisteredReaction[])">removeStrongReaction</A></B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]&nbsp;reactions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deregisters a group of strong reactions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#removeWeakReaction(lime.RegisteredReaction[])">removeWeakReaction</A></B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]&nbsp;reactions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deregisters a group of weak reactions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#setShared(boolean)">setShared</A></B>(boolean&nbsp;isShared)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable or disable transient sharing of this tuple space with tuple spaces
having the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lime/LimeTupleSpace.html#setShared(lime.LimeTupleSpace[], boolean)">setShared</A></B>(<A HREF="../lime/LimeTupleSpace.html">LimeTupleSpace</A>[]&nbsp;lts,
          boolean&nbsp;isShared)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable or disable transient sharing of a set of tuple spaces.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="SYSTEM"><!-- --></A><H3>
SYSTEM</H3>
<PRE>
public static final java.lang.String <B>SYSTEM</B></PRE>
<DL>
<DD>The name of the Lime system tuple space.</DL>
<HR>

<A NAME="DEFAULT"><!-- --></A><H3>
DEFAULT</H3>
<PRE>
public static final java.lang.String <B>DEFAULT</B></PRE>
<DL>
<DD>The default name for tuple spaces.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="LimeTupleSpace(java.lang.String)"><!-- --></A><H3>
LimeTupleSpace</H3>
<PRE>
public <B>LimeTupleSpace</B>(java.lang.String&nbsp;name)
               throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A>,
                      <A HREF="../lime/IllegalTupleSpaceNameException.html">IllegalTupleSpaceNameException</A></PRE>
<DL>
<DD>Create a named Lime tuple space. The thread that is creating the tuple
space must be an instance of <code>ILimeAgent</code>, otherwise an exception
is raised. Such thread will be the owner of the Lime tuple space, i.e.,
the only one that can invoke operations on it.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name of the tuple space.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.<DD><CODE><A HREF="../lime/IllegalTupleSpaceNameException.html">IllegalTupleSpaceNameException</A></CODE> - if the agent tries to create a
tuple space with the name SYSTEM or containing an underscore.</DL>
</DD>
</DL>
<HR>

<A NAME="LimeTupleSpace()"><!-- --></A><H3>
LimeTupleSpace</H3>
<PRE>
public <B>LimeTupleSpace</B>()
               throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A>,
                      <A HREF="../lime/IllegalTupleSpaceNameException.html">IllegalTupleSpaceNameException</A></PRE>
<DL>
<DD>Create a default Lime tuple space, named DEFAULT. The thread that is
creating the tuple space must be an instance of of
<code>ILimeAgent</code>, otherwise an exception is raised. Such thread
will be the owner of the Lime tuple space, i.e., the only one that can
invoke operations on it. <p><DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="isOwner()"><!-- --></A><H3>
isOwner</H3>
<PRE>
public boolean <B>isOwner</B>()</PRE>
<DL>
<DD>Return <code>true</code> if the thread calling this method is the
<code>ILimeAgentAgent</code> object that owns this Lime tuple space
object, <code>false</code> otherwise. The owner of the Lime tuple space is
the agent which created it. This agent is the only agent in the system
that is allowed to perform an operation on this Lime tuple space.

<P> This fact has non-trivial consequences, because attention must be put
in ensuring that no other thread is issuing operations on this tuple
space. In particular, this is true for user interfaces, where AWT/Swing
listeners are executed in a thread that is created by the Java
VM. Consequently, GUI listeners can never call directly a method on the
Lime tuple space of an agent, otherwise an
<code>IllegalTupleSpaceAccessException</code> is raised. Instead, they
must somehow coordinate with the agent they are associated with (typically
by means of an operation queue, as in <code>LimeConsole</code>), and
have the latter perform the operation. In any case, tuple space operations
in GUI applications may be dangerous. For instance, a <code>rd</code>
perform from an AWT/Swing listener when no matching tuple is available
effectively blocks the AWT/Swing thread, thus for instance preventing a
correct repainting.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setShared(boolean)"><!-- --></A><H3>
setShared</H3>
<PRE>
public boolean <B>setShared</B>(boolean&nbsp;isShared)</PRE>
<DL>
<DD>Enable or disable transient sharing of this tuple space with tuple spaces
having the same name.  When a tuple space changes its status from private
to shared, it is implicitly engaged with the other tuple spaces in the
system.  When a tuple space changes its status from shared to private, it
is disengaged from any other tuple spaces it was engaged with (both local
and remote). Setting a tuple space to shared has no effect if the tuple
space is already shared, i.e., no engagement protocol is started. Same
holds for setting a private tuple space to private, i.e., no disengagement
protocol is started.  

<p> Note: setting a tuple space to shared is different from calling engage
on the LimeServer.  setShared operates only on the public/private status
of a tuple space while engage/disengage operate on the status of the host
which is holding the tuple spaces.

<p> Note: If an agent calls setShared(false) on a LimeTupleSpace, and that
LimeTupleSpace is the last shared tuple space on that host, then the
effect is the same as calling both LimeServer.disengage() and
lts.setShared(false) (as one atomic step).  The reason: we made the
decision that it does not make sense for a host to be in the engaged Lime
community if it has nothing which it is sharing.  So, when it has nothing
more to share, it is removed (disengaged) from the Lime Community (where a
Lime community is a group of engaged hosts). <p><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isShared</CODE> - <code>true</code> to set the tuple spaces to shared,
<code>false</code> to set it to private.<DT><B>Returns:</B><DD><code>true</code> if the tuple space is successfully
engaged/disengaged.</DL>
</DD>
</DL>
<HR>

<A NAME="setShared(lime.LimeTupleSpace[], boolean)"><!-- --></A><H3>
setShared</H3>
<PRE>
public static boolean <B>setShared</B>(<A HREF="../lime/LimeTupleSpace.html">LimeTupleSpace</A>[]&nbsp;lts,
                                boolean&nbsp;isShared)</PRE>
<DL>
<DD>Enable or disable transient sharing of a set of tuple spaces. When a
tuple space changes its status from private to shared, it is implicitly
engaged with the other tuple spaces in the system.  When a tuple space
changes its status from shared to private, it is disengaged from any other
tuple spaces it was engaged with (both local and remote).  The transition
from private to shared (or vice versa) is performed <I>in one atomic
step</I>, so that all tuple spaces in the array are engaged or disengaged
as part of the same transaction. Setting a tuple space to shared has no
effect if the tuple space is already shared, i.e., no engagement protocol
is started. Same holds for setting a private tuple space to private
i.e., no disengagement protocol is started. 

<p> Note: setting a tuple space to shared is different from calling engage
on the LimeServer.  setShared operates only on the public/private status
of a tuple space while engage/disengage operate on the status of the host
which is holding the tuple spaces. 

<p> Note: If an agent calls setShared(false) on a LimeTupleSpace, and that
LimeTupleSpace is the last shared tuple space on that host, then the
effect is the same as calling both LimeServer.disengage() and
lts.setShared(false) (as one atomic step).  The reason: we made the
decision that it does not make sense for a host to be in the engaged Lime
community if it has nothing which it is sharing.  So, when it has nothing
more to share, it is removed (disengaged) from the Lime Community (where a
Lime community is a group of engaged hosts). <p><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lts</CODE> - an array of tuple spaces to be set to shared or not shared in
one step.<DD><CODE>isShared</CODE> - <code>true</code> to set the tuple spaces to shared,
<code>false</code> to set it to private.<DT><B>Returns:</B><DD><code>true</code> if engagement/disengagment was successful.</DL>
</DD>
</DL>
<HR>

<A NAME="isShared()"><!-- --></A><H3>
isShared</H3>
<PRE>
public boolean <B>isShared</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if this tuple space is currently shared,
 <code>false</code> otherwise.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>()</PRE>
<DL>
<DD>Get the name of the Lime tuple space as given by the user.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="out(lights.interfaces.ITuple)"><!-- --></A><H3>
out</H3>
<PRE>
public void <B>out</B>(lights.interfaces.ITuple&nbsp;tuple)
         throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Inserts a tuple in the shared tuple space. Whether a formal can be
written or not to the tuple space and what are the matching rules in
this case depends on the rules of the underlying tuple space engine. <P>

Since no destination location is specified in this method, the tuple is
inserted in the ITS of the agent that owns this Lime tuple space object.
The reactive program is executed to termination before this operation
returns.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tuple</CODE> - the tuple to be inserted.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="out(lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
out</H3>
<PRE>
public void <B>out</B>(<A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                lights.interfaces.ITuple&nbsp;tuple)
         throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Inserts a tuple in the shared tuple space. Whether a formal can be
written or not to the tuple space and what are the matching rules in
this case depends on the rules of the underlying tuple space engine. <P>

A destination (agent) location for the tuple must be specified. If the
agent is currently connected, the tuple is delivered to the agent's ITS
before the operation returns. Otherwise, the tuple is inserted in the
ITS of the agent invoking this operation, thus becoming a "misplaced"
tuple.  If and when the recipient of the tuple appears in the system,
the misplaced tuple will be delivered to its ITS as a consequence of the
engagement process (note: it is possible for any agent to remove a
misplaced tuple before it reaches its destination).  The destination
location can be left unspecified (using
<code>AgentLocation.UNSPECIFIED</code>), in which case this operation is
equivalent to the one without a location parameter.  The reactive
program is executed to termination before this operation returns.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>destination</CODE> - the agent location specifying the ITS to which the
tuple is destined.<DD><CODE>tuple</CODE> - the tuple to be inserted.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="outg(lime.AgentLocation, lights.interfaces.ITuple[])"><!-- --></A><H3>
outg</H3>
<PRE>
public void <B>outg</B>(<A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                 lights.interfaces.ITuple[]&nbsp;tuples)
          throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Write a set of tuples to the tuple space.  All tuples must be destined
for the same tuple space.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>destination</CODE> - the agent location specifying the ITS to which the
tuples are destined<DD><CODE>tuples</CODE> - the tuples to be inserted<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underling tuple space engine</DL>
</DD>
</DL>
<HR>

<A NAME="in(lights.interfaces.ITuple)"><!-- --></A><H3>
in</H3>
<PRE>
public lights.interfaces.ITuple <B>in</B>(lights.interfaces.ITuple&nbsp;template)
                            throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a tuple that matches a given template, and removes it from the
tuple space. The whole transiently shared tuple space is searched. If
multiple tuples match the template, one is selected
non-deterministically. If no matching tuple is present the operation
blocks until such tuple is actually found and retrieved from the tuple
space.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="inp(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
inp</H3>
<PRE>
public lights.interfaces.ITuple <B>inp</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                    lights.interfaces.ITuple&nbsp;template)
                             throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a tuple that matches a given template, and removes it from the
tuple space, or returns <code>null</code> if no matching tuple
exists. Only the projection of the transiently shared tuple space
defined by the current and destination locations are searched. If
multiple tuples match the template, one is selected
non-deterministically.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the current location of the tuples can never be left
unspecified, i.e., neither the value
<code>HostLocation.UNSPECIFIED</code> nor
<code>AgentLocation.UNSPECIFIED</code> are allowed, since probe
operations are not allowed on the federated tuple space.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed.<DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template, or <code>null</code>
if the tuple cannot be found.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="ing(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
ing</H3>
<PRE>
public lights.interfaces.ITuple[] <B>ing</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                      <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                      lights.interfaces.ITuple&nbsp;template)
                               throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieve all tuples that match a pattern.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the currnet location of the tuples that can be searched.
The value <code>AgentLocation.UNSPECIFIED</code> is NOT allowed.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed.<DD><CODE>template</CODE> - the template the return tuples must be matched against.<DT><B>Returns:</B><DD>an array of all matching tuples, or <code>null</code> if no
matching tuple can be found<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="in(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
in</H3>
<PRE>
public lights.interfaces.ITuple <B>in</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                   <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                   lights.interfaces.ITuple&nbsp;template)
                            throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a tuple that matches a given template, and removes it from the
tuple space. Only the projection of the transiently shared tuple space
defined by the current and destination locations are searched. If
multiple tuples match the template, one is selected
non-deterministically. If no matching tuple is present the operation
blocks until such a tuple is actually found and retrieved from the
tuple space.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the current location of the tuples that can be
matched. The value <code>HostLocation.UNSPECIFIED</code> or
<code>AgentLocation.UNSPECIFIED</code> are allowed, in which case only
the destination location will matter.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed, in
which case only the current location will matter.<DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="rd(lights.interfaces.ITuple)"><!-- --></A><H3>
rd</H3>
<PRE>
public lights.interfaces.ITuple <B>rd</B>(lights.interfaces.ITuple&nbsp;template)
                            throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a copy of a tuple that matches a given template.  The whole
transiently shared tuple space is searched. If multiple tuples match the
template, one is selected non-deterministically. If no matching tuple is
present the operation blocks until such a tuple is actually found in the
tuple space.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="rdp(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
rdp</H3>
<PRE>
public lights.interfaces.ITuple <B>rdp</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                    <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                    lights.interfaces.ITuple&nbsp;template)
                             throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a copy of a tuple that matches a given template, or returns
<code>null</code> if no matching tuple exists. Only the projection of
the transiently shared tuple space defined by the current and
destination locations are searched. If multiple tuples match the
template, one is selected non-deterministically.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the current location of the tuples can never be left
unspecified, i.e., neither the value
<code>HostLocation.UNSPECIFIED</code> nor
<code>AgentLocation.UNSPECIFIED</code> are allowed, since probe
operations are not allowed on the federated tuple space.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed.<DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template, or <code>null</code>
if the tuple cannot be found.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="rdg(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
rdg</H3>
<PRE>
public lights.interfaces.ITuple[] <B>rdg</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                      <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                      lights.interfaces.ITuple&nbsp;template)
                               throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Copy all tuples that match a pattern.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the currnet location of the tuples that can be searched.
The value <code>AgentLocation.UNSPECIFIED</code> is NOT allowed.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed.<DD><CODE>template</CODE> - the template the return tuples must be matched against.<DT><B>Returns:</B><DD>an array of all matching tuples, or <code>null</code> if no
matching tuple can be found<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="rd(lime.Location, lime.AgentLocation, lights.interfaces.ITuple)"><!-- --></A><H3>
rd</H3>
<PRE>
public lights.interfaces.ITuple <B>rd</B>(<A HREF="../lime/Location.html">Location</A>&nbsp;current,
                                   <A HREF="../lime/AgentLocation.html">AgentLocation</A>&nbsp;destination,
                                   lights.interfaces.ITuple&nbsp;template)
                            throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Retrieves a copy of a tuple that matches a given template. Only the
projection of the transiently shared tuple space defined by the current
and destination locations are searched. If multiple tuples match the
template, one is selected non-deterministically. If no matching tuple is
present the operation blocks until such a tuple can be actually found in
the tuple space.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - the current location of the tuples that can be
matched. The value <code>HostLocation.UNSPECIFIED</code> or
<code>AgentLocation.UNSPECIFIED</code> are allowed, in which case only
the destination location will matter.<DD><CODE>destination</CODE> - the destination location of the tuple that can be
searched. The value <code>AgentLocation.UNSPECIFIED</code> is allowed, in
which case only the current location will matter.<DD><CODE>template</CODE> - the template the return tuple must be matched against.<DT><B>Returns:</B><DD>a copy of a tuple that matches the template.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="isRegisteredReaction(lime.RegisteredReaction)"><!-- --></A><H3>
isRegisteredReaction</H3>
<PRE>
public boolean <B>isRegisteredReaction</B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>&nbsp;reaction)</PRE>
<DL>
<DD>Checks whether a given reaction is still registered. A reaction can be
 deregistered explicitly by calling <code>removeReaction</code>, or
 implicitly and automatically if its mode is <code>ONCE</code> and the
 reaction has already fired.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reaction</CODE> - the <code>RegisteredReaction</code> whose presence must
 be checked.<DT><B>Returns:</B><DD><code>true</code> if <code>reaction</code> is still
 registered with the tuple space, <code>false</code> otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="getRegisteredReactions()"><!-- --></A><H3>
getRegisteredReactions</H3>
<PRE>
public <A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[] <B>getRegisteredReactions</B>()</PRE>
<DL>
<DD>Return all the reactions registered on this Lime tuple space, i.e., all
 those registered by the agent owning this Lime tuple space.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addStrongReaction(lime.LocalizedReaction[])"><!-- --></A><H3>
addStrongReaction</H3>
<PRE>
public <A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[] <B>addStrongReaction</B>(<A HREF="../lime/LocalizedReaction.html">LocalizedReaction</A>[]&nbsp;reactions)
                                       throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Registers a group of reactions with the Lime tuple space. The operation
<I><U>is performed atomically</U></I>, i.e., even if some of the
reactions become suddenly enabled by the current state of the tuple
space, none can fire until all of them have been registered. The
reactions  must have current and destination location fields.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reactions</CODE> - an array containing the reactions to be registered.<DT><B>Returns:</B><DD>returns an array of handles to the registered reactions.  These
can later be used to uninstall the reactions.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="addWeakReaction(lime.Reaction[])"><!-- --></A><H3>
addWeakReaction</H3>
<PRE>
public <A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[] <B>addWeakReaction</B>(<A HREF="../lime/Reaction.html">Reaction</A>[]&nbsp;reactions)
                                     throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></PRE>
<DL>
<DD>Registers a group of weak reactions with the Lime tuple space. The
operation <I><U>is NOT performed atomically</U></I>, as this would
involve a distributed transaction. The weak reactions obey to the
semantics specified by the <code>weakReaction</code> operation. Thus,
they can have either of the location fields unspecified, or no location
field at all (i.e., <code>UbiquitousReaction</code>s can be specified as
well.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reactions</CODE> - an array containing the reactions to be registered.<DT><B>Returns:</B><DD>returns an array of handles to the registered reactions.  These
can later be used to uninstall the reactions.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="removeStrongReaction(lime.RegisteredReaction[])"><!-- --></A><H3>
removeStrongReaction</H3>
<PRE>
public void <B>removeStrongReaction</B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]&nbsp;reactions)
                          throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A>,
                                 <A HREF="../lime/NoSuchReactionException.html">NoSuchReactionException</A></PRE>
<DL>
<DD>Deregisters a group of strong reactions. The operation <I><U>is performed
atomically</U></I>, i.e., the reactions are deregistered all together
before any other operation or reaction is performed on the tuple space.
This operation has all-or-nothing semantics, meaning that either all of
the reactions are uninstalled, or none of them are.  In other words, if
at least one of the reactions specified in the array is not registered
with the tuple space, then none of the reactions are disabled and
<code>NoSuchReactionException</code> is raised.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reactions</CODE> - an array containing the reactions to be deregistered.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/NoSuchReactionException.html">NoSuchReactionException</A></CODE> - if some of the reactions are actually
not registered.<DD><CODE><A HREF="../lime/IllegalTupleSpaceAccessException.html">IllegalTupleSpaceAccessException</A></CODE> - if an agent other than the
owner is trying to access this tuple space.<DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.<DD><CODE><A HREF="../lime/NoSuchReactionException.html">NoSuchReactionException</A></CODE> - if at least one of the reactions
which was being removed does not exist..</DL>
</DD>
</DL>
<HR>

<A NAME="removeWeakReaction(lime.RegisteredReaction[])"><!-- --></A><H3>
removeWeakReaction</H3>
<PRE>
public void <B>removeWeakReaction</B>(<A HREF="../lime/RegisteredReaction.html">RegisteredReaction</A>[]&nbsp;reactions)
                        throws <A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A>,
                               <A HREF="../lime/NoSuchReactionException.html">NoSuchReactionException</A></PRE>
<DL>
<DD>Deregisters a group of weak reactions. The operation <I><U>is NOT performed
atomically</U></I>.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reactions</CODE> - an array containing the weak reactions to be deregistered.<DT><B>Throws:</B><DD><CODE><A HREF="../lime/NoSuchReactionException.html">NoSuchReactionException</A></CODE> - if some of the weak reactions are
actually not registered.<DD><CODE><A HREF="../lime/TupleSpaceEngineException.html">TupleSpaceEngineException</A></CODE> - if a problem is encountered in the
underlying tuple space engine.</DL>
</DD>
</DL>
<HR>

<A NAME="print()"><!-- --></A><H3>
print</H3>
<PRE>
public void <B>print</B>()</PRE>
<DL>
<DD>Prints the contents of the tuple space.  If the tuple space is shared,
 the host level tuple space is printed. Useful for debugging.<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LimeTupleSpace.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../lime/LimeTupleID.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../lime/LocalizedReaction.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LimeTupleSpace.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
