/* Configuration file containing entries used to configure 
 * the activation group VM that is spawned by Phoenix, and
 * which uses secure JERI/jsse for remote communication.
 *
 * For more information, such as an example command line for
 * starting Phoenix, see the configuration file for the
 * corresponding implementation of Phoenix that specifies
 * this configuration file for its activation group VM.
 *
 * Note that the Phoenix activation group exports one remote
 * object:
 *  - activation instantiator
 * That object is exported using an Exporter obtained from this
 * configuration file. The Phoenix activation group VM provides
 * various classes to facilitate the configuration of that
 * exporter, as shown below. The remote object that must be
 * exported does not implement any access control directly; any
 * desired access control must be implemented through that
 * object's exporter, specified in this configuration.
 *
 * For example, recall that the exporter will use a factory 
 * (supplied to the exporter) to generate client-side invocation
 * handlers that will be used in secure dynamic proxies to
 * execute calls to secure remote objects; and to also generate
 * server-side dispatchers used to receive those incoming remote
 * calls from the dynamic proxies. 
 */
import com.sun.jini.config.KeyStores;
import com.sun.jini.phoenix.InstantiatorPermission;

import net.jini.core.constraint.ClientAuthentication;
import net.jini.core.constraint.Integrity;
import net.jini.core.constraint.InvocationConstraint;
import net.jini.core.constraint.InvocationConstraints;
import net.jini.core.constraint.ServerAuthentication;
import net.jini.core.constraint.ServerMinPrincipal;

import net.jini.security.AuthenticationPermission;
import net.jini.constraint.BasicMethodConstraints;
import net.jini.security.BasicProxyPreparer;

import net.jini.jeri.BasicJeriExporter;
import net.jini.jeri.ProxyTrustILFactory;

import net.jini.jeri.ssl.SslServerEndpoint;

import javax.security.auth.login.LoginContext;

import java.security.Permission;
import java.util.Collections;

com.sun.jini.phoenix {

    /* Public Key Certificate(s) ------------------------------------------------ */

    /* Retrieve from the configuration, the location of the truststore 
     * containing the public key certificates associated with the various
     * entities in the system.
     */
    private static caTruststore = KeyStores.getKeyStore("${appHome}${/}example${/}common${/}jsse${/}truststore${/}jini-ca.truststore", null);

    /* Retrieve from the truststore above, the public key certificate 
     * associated with Phoenix.
     */
    private static phoenixPublicKeyCert = Collections.singleton(KeyStores.getX500Principal("phoenix", caTruststore));

    /* Exporter(s) -------------------------------------------------------------- */

    /* Create the per-method constraints to apply to the remote methods called
     * on the activation instantiator. Require the following when a client
     * attempts to make a remote call on either object:
     *  - integrity of the call (verify no one corrupts the call)
     *  - authenticate the client making the call
     */
    private activationConstraints
         = new BasicMethodConstraints( new InvocationConstraints
                                           ( new InvocationConstraint[]{ Integrity.YES
                                                                       ,ClientAuthentication.YES
                                                                     },
                                             null)
                                     );

    /* Create a secure endpoint - with default port - to be used when
     * creating the exporter for the activation instantiator 
     * (ActivationGroupImpl)
     */
    private activationInstantiatorEndpoint = SslServerEndpoint.getInstance(0);

    /* Create the exporter to use to export the activation instantiator.
     * Configure the exporter to export the activation instantiator in the
     * following way:
     *  - use JERI for remote communciation
     *  - when accepting network connections, use the endpoint specified
     *    above
     *  - generate a secure dynamic proxy to the object exported by
     *    this exporter
     *  - use an invocation layer factory with the following
     *    characteristics:
     *    o generates a dynamic proxy that uses JERI for remote
     *      communication, and additionally implements the ProxyTrust
     *      interface
     *    o with respect to the dynamic proxy generated by the
     *      exporter, this invocation layer factory generates the
     *      client-side invocation handler used in that proxy to execute
     *      calls to the remote object that is exported by this
     *      exporter
     *    o generates the server-side dispatcher used to receive the
     *      incoming remote calls from the client-side invocation
     *      handler to the object exported by this exporter
     *    o applies the constraints specified above when a client attempts
     *      to make a call to a remote method on the exported object
     *    o grants the specified permission to the dispatcher so that
     *      it may perform automatic permission-based access control
     *      on incoming remote calls
     */
    instantiatorExporter =
    new BasicJeriExporter(activationInstantiatorEndpoint,
                          new ProxyTrustILFactory(activationConstraints,
                                                  InstantiatorPermission.class)
                          );

    /* Proxy Preparer(s) -------------------------------------------------------- */

    /* Create a set of security constraints to apply under the following
     * circumstances:
     *  - when the activation instantiator or the activation monitor prepares
     *    a proxy, trust in that proxy is verified using the constraints
     *    specified here.
     *
     * The constraints specified here require the following when a client
     * attempts to make a remote call:
     *  - integrity of the call (verify no one corrupts the call)
     *  - authenticate the client making the call
     *  - authenticate the server receiving the call
     *  - when it authenticates itself, require that the server authenticate
     *    itself as at least all of the specified principals; in the case
     *    below, as the alias "phoenix". Note that the mechanisms and credentials
     *    used to authenticate the server as that principal are not specified
     *    here. 
     */
    private mutualAuthenticationConstraints
         = new BasicMethodConstraints( new InvocationConstraints
                                           ( new InvocationConstraint[]{ Integrity.YES,
                                                                       ClientAuthentication.YES,
                                                                       ServerAuthentication.YES,
                                                                       new ServerMinPrincipal(phoenixPublicKeyCert)
                                                                     },
                                             null)
                                     );

    /* Create the proxy preparer the activation group should use
     * to prepare proxies to the activation system. This preparer
     * should verify trust in those proxies using the constraints
     * specified above. And it should grant to those proxies the
     * following permission(s):
     *
     * When requesting a connection to an entity, running in another VM, 
     * that authenticates as at lease the principal "phoenix", the 
     * preparer dynamically grants to the proxy, permission to authenticate 
     * as no more than the principal "phoenix". Although the affected 
     * proxies are allowed to make outbound calls ("connect") under the
     * conditions just stated, they are not allowed to accept incoming
     * calls, nor would delegation be allowed were those proxies allowed
     * to actually make outbound calls.
     */
    systemPreparer = new BasicProxyPreparer( true,
                                             mutualAuthenticationConstraints,
                                             new Permission[] { new AuthenticationPermission(phoenixPublicKeyCert,
                                                                                             phoenixPublicKeyCert,
                                                                                             "connect")
                                                              }
                                           );

    /* Set the proxy preparer the activation group should use
     * to prepare proxies to the activation monitor to be the
     * same as the preparer used to prepare proxies to the activation
     * system.
     */
    monitorPreparer = systemPreparer;

    /* JAAS Login --------------------------------------------------------------- */

    /* For every object in the Phoenix activation group VM that must perform a
     * JAAS login, the JAAS login configuration should contain an entry that
     * identifies the following information used in the login process:
     *  - the keystore from which to retrieve the private key used to login
     *  - the alias of the private key to retrieve
     *  - the (optional) location of the password file(s) from which to retrieve
     *    the appropriate password(s) needed to retrieve the private key information
     *
     * The item below identifies the entry to use, from Phoenix's JAAS login 
     * configuration file, when an object in that VM performs a JAAS login.
     */
    loginContext = new LoginContext("phoenix.jaas.login");

    /* Application-specific Items ----------------------------------------------- */

    /* None */

}//end com.sun.jini.phoenix
