/* Configuration file containing entries used to configure the
 * SharedGroupImpl when using the ServiceStarter framework to
 * destroy an activation group VM in which secure JERI/jsse is
 * used for remote communication.
 *
 * The ServiceStarter framework destroys the activation group
 * VM by registering a SharedGroupImpl object with the 
 * activation system (like any other activatable service) and
 * activating that object in the VM to be destroyed. The
 * ServiceStarter then invokes that object's destroyVM()
 * method, ultimately executing a call to System.exit() which
 * destroys the VM in which the object (as well as any other
 * objects) is running.
 */
import com.sun.jini.config.KeyStores;

import net.jini.activation.ActivationExporter;

import net.jini.core.constraint.ClientAuthentication;
import net.jini.core.constraint.Integrity;
import net.jini.core.constraint.InvocationConstraint;
import net.jini.core.constraint.InvocationConstraints;
import net.jini.core.constraint.ServerAuthentication;
import net.jini.core.constraint.ServerMinPrincipal;

import net.jini.security.AuthenticationPermission;
import net.jini.constraint.BasicMethodConstraints;
import net.jini.security.BasicProxyPreparer;

import net.jini.jeri.ProxyTrustILFactory;
import net.jini.jeri.BasicJeriExporter;

import net.jini.jeri.ssl.SslServerEndpoint;
import javax.security.auth.login.LoginContext;

import java.rmi.activation.ActivationID;
import java.util.Collections;
import java.security.Permission;

com.sun.jini.start {

    /* Public Key Certificate(s) ------------------------------------------------ */

    /* Retrieve from the configuration, the location of the truststore 
     * containing the public key certificates associated with the various
     * entities in the system.
     */
    private static caTruststore = KeyStores.getKeyStore("${appHome}${/}example${/}common${/}jsse${/}truststore${/}jini-ca.truststore", null);

    /* Retrieve from the truststore above, the public key certificate 
     * associated with the entity that plays a role in destroying the
     * activation group VM.
     */
    private static phoenixPublicKeyCert = Collections.singleton(KeyStores.getX500Principal("phoenix", caTruststore));

    /* Exporter(s) -------------------------------------------------------------- */

    /* Because the ServiceStarter framework registers an instance of
     * SharedGroupImpl with the activation system, that object must be
     * exported (see SharedGroupImpl.doInit()). The required exporter
     * is specified below.
     */

    /* Create a Secure JERI transport server endpoint that listens
     * on an arbitrary port, and that uses SSL to support the server
     * side of direct TCP/IP connections. This endpoint will be used
     * to create the SharedGroupImpl's exporter.
     */
    private serviceEndpoint = SslServerEndpoint.getInstance(0);

    /* Create the per-method constraints to apply to the remote methods called
     * on the proxy to the SharedGroupImpl's backend. Require the following
     * when a client attempts to make a remote call on the SharedGroupImpl:
     *  - integrity of the call (verify no one corrupts the call)
     *  - authenticate the client making the call
     */
    private serviceConstraints = new BasicMethodConstraints(new InvocationConstraints(new InvocationConstraint[]{ Integrity.YES,
                                                                                                              ClientAuthentication.YES
                                                                                                             },
                                                                                     null)
                                                            );

    /* Create the invocation layer factory to use when creating the
     * SharedGroupImpl's exporter. That exporter will export the
     * SharedGroupImpl as an activatable remote object that uses
     * Secure JERI for its remote communication.
     *
     * The invocation layer factory created here has the following
     * characteristics:
     *  - uses Secure JERI for remote communication
     *  - with respect to the secure dynamic proxy generated by the
     *    SharedGroupImpl's exporter, this invocation layer factory
     *    generates the client-side invocation handler used in that
     *    proxy to execute calls to the SharedGroupImpl's backend,
     *    which is the secure remote object that is exported by the
     *    exporter
     *  - generates the server-side dispatcher used to receive the
     *    incoming remote calls from the client-side invocation
     *    handler to the SharedGroupImpl's backend
     *  - applies the constraints specified above when a client attempts
     *    to make a call to a remote method on the exported object
     *  - grants the specified service-specific permission to the 
     *    dispatcher so that it may perform automatic permission-based
     *    access control on incoming remote calls
     *
     * Note that when a client invokes a remote method on the backend's
     * proxy, the dispatcher receives that call, determines the appropriate
     * backend method to invoke, and then invokes that method on the
     * backend. Both the client and the dispatcher must be granted this
     * permission. When the client is granted that permission, the
     * specific methods the client is allowed to invoke are usually also
     * specified in conjunction with that permission, in the
     * SharedGroupImpl's policy file; and that permission is typically
     * granted to only the principal(s) under which the client is
     * running, (not to the client's code source). With respect to the
     * dispatcher, that permission is granted when the dispatcher is
     * constructed by the invocation factory. Unlike the client, the
     * dispatcher is typically granted broad access to the methods of
     * the backend.
     */
    private serviceILFactory = new ProxyTrustILFactory(serviceConstraints,
                                                       RuntimePermission.class);

    /* Create the underlying exporter that should be used to create
     * the exporter that exports the SharedGroupImpl's backend. Configure
     * this exporter to operate in the following way:
     *  - uses Secure JERI for remote communciation
     *  - when accepting network connections, use the endpoint specified
     *    above
     *  - generates a secure dynamic proxy to the exported object (the
     *    SharedGroupImpl) that, through the implementation of the ProxyTrust
     *    interface, provides a mechanism for obtaining a trust verifier
     *    for the proxy
     *  - uses the invocation layer factory specified above to generate
     *    the server-side dispatcher for the service, and to generate the
     *    client-side invocation handler for the SharedGroupImpl's dynamic
     *    proxy
     */
    private underlyingServiceExporter = new BasicJeriExporter(serviceEndpoint, serviceILFactory);

    /* Create the actual exporter to use to export the SharedGroupImpl's
     * backend as an activatable remote object. This exporter is created
     * using the underlying exporter specified above.
     */
    exporter = new ActivationExporter((ActivationID)$data, underlyingServiceExporter);

    /* Proxy Preparer(s) -------------------------------------------------------- */

    /* The SharedGroupImpl interacts with the activation framework through
     * a proxy to the activation system. As such, the SharedGroupImpl should
     * prepare that proxy before attempting to use it. A preparer for that
     * proxy is specifed below.
     */

    /* Create a set of security constraints to apply under the following
     * circumstances:
     *  - when the SharedGroupImpl prepares a proxy to the activation system,
     *    trust in that proxy is verified using the constraints specified here.
     *
     * The constraints specified here require the following when a client
     * attempts to make a remote call:
     *  - integrity of the call (verify no one corrupts the call)
     *  - authenticate the client making the call
     *  - authenticate the server receiving the call
     *  - when it authenticates itself, require that the server authenticate
     *    itself as at least all of the specified principals; in the case
     *    below, as the alias "phoenix". Note that the mechanisms and credentials
     *    used to authenticate the server as that principal are not specified
     *    here. 
     */
    private activationProxyConstraints
         = new BasicMethodConstraints( new InvocationConstraints
                                           ( new InvocationConstraint[]{ Integrity.YES,
                                                                       ServerAuthentication.YES,
                                                                       ClientAuthentication.YES,
                                                                       new ServerMinPrincipal(phoenixPublicKeyCert)
                                                                     },
                                             null)
                                     );

    /* Create the proxy preparer that SharedGroupImpl should use to 
     * prepare proxies to the activation system. This preparer should
     * verify trust in those proxies using the constraints specified above.
     * And it should grant to those proxies the following permission(s):
     *
     * When requesting a connection to an entity, running in another VM, 
     * that authenticates as at lease the principal "phoenix", the 
     * preparer dynamically grants to the proxy, permission to authenticate 
     * as no more than the principal "phoenix". Although the affected 
     * proxies are allowed to make outbound calls ("connect") under the
     * conditions just stated, they are not allowed to accept incoming
     * calls, nor would delegation be allowed were those proxies allowed
     * to actually make outbound calls.
     */
    activationSystemPreparer = new BasicProxyPreparer( true,
                                                       activationProxyConstraints,
                                                       new Permission[] { new AuthenticationPermission(phoenixPublicKeyCert,
                                                                                                       phoenixPublicKeyCert,
                                                                                                       "connect")
                                                                        }
                                                     );

    /* JAAS Login --------------------------------------------------------------- */

    /* For every object in the activation group VM that must perform a JAAS
     * login, the JAAS login configuration should contain an entry that
     * identifies the following information used in the login process:
     *  - the keystore from which to retrieve the private key used to login
     *  - the alias of the private key to retrieve
     *  - the (optional) location of the password file(s) from which to retrieve
     *    the appropriate password(s) needed to retrieve the private key information
     *
     * The item below identifies the entry to use, from the JAAS login configuration
     * file for the activation group VM, when an object in that VM performs a JAAS
     * login.
     */
    loginContext = new LoginContext("phoenix.jaas.login");

}//end com.sun.jini.start

