/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.sun.jini.test.share.reggie;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.rmi.server.RMIClassLoader;
import java.util.StringTokenizer;

/**
 * A ServiceType is a descriptor for a class, packaged up for
 * transmission between client-side proxies and the registrar server.
 * Instances are never visible to clients, they are private to the
 * communication between the proxies and the server.
 * <p>
 * This class only has a bare minimum of methods, to minimize
 * the amount of code downloaded into clients.
 * The implementation is complicated by a requirement to support classes
 * generated by java.lang.reflect.Proxy with a single source that will
 * compile and run against J2SE(TM) versions 1.2.x, 1.3.x, and 1.4.x.
 * <p>
 * Equality is based on object identity, on the assumption that
 * ClassResolver is always used and that equality is only interesting
 * in the registrar.
 *
 * 
 *
 * @see ClassMapper
 * @see ClassResolver
 */
class ServiceType implements java.io.Serializable {

    /**
     * Class name. If the class is generated by java.lang.reflect.Proxy,
     * then the name is of the form ";iface1;iface2;...;ifaceN".
     *
     * @serial
     */
    protected String name;
    /**
     * Descriptor for the superclass.
     *
     * @serial
     */
    protected ServiceType superclass;
    /**
     * Descriptor for the interfaces.  As a special case, interfaces is
     * null for the descriptor for java.lang.Object, and non-null otherwise.
     * This avoids carrying a boolean isInterface around.
     *
     * @serial
     */
    protected ServiceType[] interfaces;
    /**
     * An instance containing only name, no supertype info.
     * This is only used on the registrar side, to minimize the amount
     * of info transmitted back to clients.
     */
    protected transient ServiceType replacement;
    /** The concrete classes. */
    protected transient ServiceType[] concreteClasses;

    private static final long serialVersionUID = 9194732528513491231L;
    private static final ServiceType[] empty = {};
    /** Proxy.isProxyClass, if it exists (1.3 and later) */
    private static Method isProxyClass;
    /** Proxy.getProxyClass, if it exists (1.3 and later) */
    private static Method getProxyClass;
    /** RMIClassLoader.getClassLoader, if it exists (1.3 and later) */
    private static Method getClassLoader;
    /** RMIClassLoader.loadProxyClass, if it exists (1.4 and later) */
    private static Method loadProxyClass;

    static {
	try {
	    Class c = Class.forName("java.lang.reflect.Proxy");
	    isProxyClass = c.getMethod("isProxyClass",
				       new Class[]{Class.class});
	    getProxyClass = c.getMethod("getProxyClass",
					new Class[]{ClassLoader.class,
						    Class[].class});
	} catch (ClassNotFoundException e) {
	} catch (NoSuchMethodException e) {
	    throw new InternalError(e.toString());
	}
	try {
	    getClassLoader = RMIClassLoader.class.getMethod(
				  "getClassLoader", new Class[]{String.class});
	    loadProxyClass = RMIClassLoader.class.getMethod(
				  "loadProxyClass",
				  new Class[]{String.class, String[].class,
					      ClassLoader.class});
	} catch (NoSuchMethodException e) {
	}
    }

    /** Should only be called by ClassMapper */
    public ServiceType(Class clazz,
		       ServiceType superclass,
		       ServiceType[] interfaces)
    {
	try {
	    if (isProxyClass == null ||
		!((Boolean) isProxyClass.invoke(
				  null, new Object[]{clazz})).booleanValue())
	    {
		name = clazz.getName();
	    } else if (interfaces.length == 0) {
		name = ";";
	    } else {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < interfaces.length; i++) {
		    buf.append(';');
		    buf.append(interfaces[i].getName());
		}
		name = buf.toString();
	    }
	} catch (IllegalAccessException e) {
	    throw new InternalError(e.toString());
	} catch (InvocationTargetException e) {
	    Throwable t = e.getTargetException();
	    if (t instanceof RuntimeException)
		throw (RuntimeException) t;
	    if (t instanceof Error)
		throw (Error) t;
	    throw new InternalError(t.toString());
	}
	this.superclass = superclass;
	if (clazz != Object.class)
	    this.interfaces = interfaces;
    }

    /**
     * Constructor used for creating replacement instances,
     * containing only name.
     */
    private ServiceType(ServiceType stype) {
	name = stype.name;
    }

    /** Return the class name */
    public String getName() {
	return name;
    }

    /** Return the superclass descriptor */
    public ServiceType getSuperclass() {
	return superclass;
    }

    /** Return the interfaces.  The array is not a copy; do not modify it. */
    public ServiceType[] getInterfaces() {
	if (interfaces != null)
	    return interfaces;
	return empty;
    }

    /** Return the replacement, if any, containing only name and rep. */
    public ServiceType getReplacement() {
	return replacement;
    }

    /**
     * This is really only needed in the registrar, but it's very
     * convenient to have here.
     * @see Class#isAssignableFrom
     */
    public boolean isAssignableFrom(ServiceType cls) {
	if (this == cls)
	    return true;
	if (isInterface()) {
	    if (isAssignableFrom(cls.interfaces))
		return true;
	    for (ServiceType sup = cls.superclass;
		 sup != null && sup.interfaces != null;
		 sup = sup.superclass)
	    {
		if (isAssignableFrom(sup.interfaces))
		    return true;
	    }
	} else {
	    for (ServiceType sup = cls.superclass;
		 sup != null;
		 sup = sup.superclass)
	    {
		if (this == sup)
		    return true;
	    }
	}
	return false;
    }

    /** Test if this isAssignableFrom any of the given interface types. */
    private boolean isAssignableFrom(ServiceType[] ifaces)
    {
	for (int i = ifaces.length; --i >= 0; ) {
	    if (this == ifaces[i] || isAssignableFrom(ifaces[i].interfaces))
		return true;
	}
	return false;
    }

    /** @see Class#isInterface */
    public boolean isInterface() {
	return (superclass == null && interfaces != null);
    }

    /** Converts the descriptor to a Class instance, loading from codebase */
    public Class toClass(String codebase)
	throws IOException, ClassNotFoundException
    {
	if (name.charAt(0) != ';')
	    return RMIClassLoader.loadClass(codebase, name);
	if (getProxyClass == null)
	    throw new ClassNotFoundException("java.lang.reflect.Proxy");
	StringTokenizer st = new StringTokenizer(name, ";");
	try {
	    if (loadProxyClass != null) {
		String[] ifs = new String[st.countTokens()];
		for (int i = 0; i < ifs.length; i++) {
		    ifs[i] = st.nextToken();
		}
		return (Class) loadProxyClass.invoke(
				   null, new Object[]{codebase, ifs, null});
	    }
	    ClassLoader cl = (ClassLoader) getClassLoader.invoke(
						null, new String[]{codebase});
	    Class[] ifs = new Class[st.countTokens()];
	    for (int i = 0; i < ifs.length; i++) {
		ifs[i] = Class.forName(st.nextToken(), false, cl);
	    }
	    return (Class) getProxyClass.invoke(null, new Object[]{cl, ifs});
	} catch (IllegalAccessException e) {
	    throw new InternalError(e.toString());
	} catch (InvocationTargetException e) {
	    Throwable t = e.getTargetException();
	    if (t instanceof ClassNotFoundException)
		throw (ClassNotFoundException) t;
	    if (t instanceof IOException)
		throw (IOException) t;
	    throw new ClassNotFoundException(name, t);
	}
    }

    /**
     * Sets this descriptor to be the canonical one.  Replaces the
     * superclass with the canonical superclass, and constructs the
     * replacement object.
     *
     * This should only be called by ClassResolver.
     */
    public void canonical(ServiceType superclass) {
	this.superclass = superclass;
	replacement = new ServiceType(this);
	concreteClasses = empty;
    }

    /**
     * Returns the set of all ServiceTypes T such that there is at least one
     * registered service with serviceType equal to T and for which
     * this.isAssignableFrom(T).  This is only used on the registrar side.
     */
    public ServiceType[] getConcreteClasses() {
	return concreteClasses;
    }

    /** Sets the concrete classes. */
    public void setConcreteClasses(ServiceType[] concreteClasses) {
	if (concreteClasses.length == 0)
	    concreteClasses = empty;
	this.concreteClasses = concreteClasses;
    }
}
