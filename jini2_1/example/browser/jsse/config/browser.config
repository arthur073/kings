/* Configuration file containing entries used to configure 
 * an implementation of the Browser to use secure Jini ERI/jsse
 * for remote communication.
 */
import com.sun.jini.config.KeyStores;

import net.jini.core.constraint.ClientAuthentication;
import net.jini.core.constraint.ConstraintAlternatives;
import net.jini.core.constraint.Integrity;
import net.jini.core.constraint.InvocationConstraint;
import net.jini.core.constraint.InvocationConstraints;
import net.jini.core.constraint.ServerAuthentication;
import net.jini.core.constraint.ServerMinPrincipal;

import net.jini.security.AccessPermission;
import net.jini.security.AuthenticationPermission;
import net.jini.constraint.BasicMethodConstraints;
import net.jini.security.BasicProxyPreparer;

import net.jini.jeri.ProxyTrustILFactory;
import net.jini.jeri.BasicJeriExporter;

import net.jini.jeri.ssl.SslServerEndpoint;

import javax.security.auth.login.LoginContext;

import java.security.KeyStore;
import java.security.Permission;
import java.util.Arrays;
import java.util.Collections;

/* Note that the Browser exports one remote object:
 *  - the remote listener that receives events from the lookup service(s)
 */
com.sun.jini.example.browser {

    /* Public Key Certificate(s) ------------------------------------------------ */

    /* Retrieve from the configuration, the location of the truststore 
     * containing the public key certificates associated with the various
     * entities in the system.
     */
    private static caTruststore = KeyStores.getKeyStore("${appHome}${/}example${/}common${/}jsse${/}truststore${/}jini-ca.truststore", null);

    /* Retrieve from the truststore above, the public key certificate 
     * associated with each of the entities that play a role in
     * starting the Browser.
     */
    private static clientKey    = KeyStores.getX500Principal("client",    caTruststore);
    private static reggieKey    = KeyStores.getX500Principal("reggie",    caTruststore);
    private static mahaloKey    = KeyStores.getX500Principal("mahalo",    caTruststore);
    private static fiddlerKey   = KeyStores.getX500Principal("fiddler",   caTruststore);
    private static normKey      = KeyStores.getX500Principal("norm",      caTruststore);
    private static mercuryKey   = KeyStores.getX500Principal("mercury",   caTruststore);
    private static outriggerKey = KeyStores.getX500Principal("outrigger", caTruststore);

    private static clientPublicKeyCert     = Collections.singleton(clientKey);
    private static reggiePublicKeyCert     = Collections.singleton(reggieKey);
    private static mahaloPublicKeyCert     = Collections.singleton(mahaloKey);
    private static fiddlerPublicKeyCert    = Collections.singleton(fiddlerKey);
    private static normPublicKeyCert       = Collections.singleton(normKey);
    private static mercuryPublicKeyCert    = Collections.singleton(mercuryKey);
    private static outriggerPublicKeyCert  = Collections.singleton(outriggerKey);

    private static serviceKeyArray = new Object[] { clientKey,
                                                    reggieKey,
                                                    mahaloKey,
                                                    fiddlerKey,
                                                    normKey,
                                                    mercuryKey,
                                                    outriggerKey
                                                  };

    private static servicePublicKeys = new java.util.HashSet(Arrays.asList(serviceKeyArray));

    /* Exporter(s) -------------------------------------------------------------- */

    /* Create a secure Jini ERI/jsse transport server endpoint that listens
     * on an arbitrary port, and that uses SSL to support the server
     * side of direct TCP/IP connections. This endpoint will be used
     * to create the Browser's exporter.
     */
    private listenerEndpoint = SslServerEndpoint.getInstance(0);

    /* Create the per-method constraints to apply to the remote methods called
     * on the proxy to the Browser's listener. Require the following when a
     * lookup service attempts to make a remote call on the service:
     *  - integrity of the call (verify no one corrupts the call)
     */
    private listenerConstraints = new BasicMethodConstraints(new InvocationConstraints(new InvocationConstraint[]{ Integrity.YES },
                                                                                       null)
                                                            );

    /* Create the invocation layer factory to use when creating the
     * Browser's exporter. The invocation layer factory created here
     * has the following characteristics:
     *
     *  - uses secure Jini ERI/jsse for remote communication
     *  - with respect to the secure dynamic proxy generated by the
     *    Browwer's exporter, this invocation layer factory generates
     *    the client-side invocation handler used in that proxy to
     *    execute calls to the backend of the Browser's listener, 
     *    which is the secure remote object that is exported by the 
     *    exporter
     *  - generates the server-side dispatcher used to receive the
     *    incoming remote calls from the client-side invocation
     *    handler to the backend of the Browser's listener
     *  - applies the constraints specified above when a lookup service
     *    attempts to make a call to a remote method on the exported
     *    listener
     *  - grants the specified Browser-specific permission to the 
     *    dispatcher so that it may perform automatic permission-based
     *    access control on incoming remote calls
     *
     * Note that when a lookup service invokes a remote method on the
     * listener's proxy, the dispatcher receives that call, determines
     * the appropriate backend listener method (notify) to invoke, and 
     * then invokes that method on the listener. Both the lookup service
     * and the dispatcher must be granted AccessPermission. 
     *
     * When the lookup service is granted that permission, the specific
     * methods the lookup service is allowed to invoke are usually also
     * specified in conjunction with that permission, in the Browser's
     * policy file; and that permission is typically granted to only the
     * principal(s) under which the lookup service is running, (not to
     * the lookup service's code source). With respect to the dispatcher,
     * the AccessPermission is granted when the dispatcher is constructed
     * by the invocation layer factory. Unlike the lookup service, the
     * dispatcher is typically granted broad access to the methods of
     * the listener's backend.
     */
    private listenerILFactory = new ProxyTrustILFactory(listenerConstraints,
                                                        AccessPermission.class);

    /* Create the exporter that should be used to export the Browser's listener.
     * Configure this exporter to operate in the following way:
     *  - uses secure Jini ERI/jsse for remote communciation
     *  - when accepting network connections, use the endpoint specified
     *    above
     *  - generates a secure dynamic proxy to the exported object (the
     *    listener) that, through the implementation of the ProxyTrust
     *    interface, provides a mechanism for obtaining a trust verifier
     *    for the proxy
     *  - uses the invocation layer factory specified above to generate
     *    the server-side dispatcher for the listener, and to generate
     *    the client-side invocation handler for the listener's dynamic
     *    proxy
     */
    listenerExporter = new BasicJeriExporter(listenerEndpoint, listenerILFactory);

    /* Proxy Preparer(s) -------------------------------------------------------- */

    /* The Browser receives a number of proxies through which the Browser makes
     * remote calls. Thus, a preparer must be configured so that the Browser
     * can prepare (verify trust in, set constraints on, etc) each such
     * proxy that it receives and interacts with.
     *
     * Create a preparer for all target proxies with the following
     * constraints:
     *  - integrity of the call (verify no one corrupts the call)
     *  - client authentication (the 'client' [the Browser] that
     *    makes calls on the proxy must tell the 'server' 
     *    [the backen of the proxy] who it is)
     *  - server authentication (the 'client' requires the 'server'
     *    to identify itself to the 'client')
     *  - when performing server athentication, the 'server' [the Browser
     *    which communicates through the proxy] must authenticate as at
     *    least one of the principals in the given list; which is 
     *    ultimately expressed as ConstraintAlternatives
     */
    private proxyPrincipals = new InvocationConstraint[]{ new ServerMinPrincipal(clientPublicKeyCert),
                                                          new ServerMinPrincipal(reggiePublicKeyCert),
                                                          new ServerMinPrincipal(mahaloPublicKeyCert),
                                                          new ServerMinPrincipal(fiddlerPublicKeyCert),
                                                          new ServerMinPrincipal(normPublicKeyCert),
                                                          new ServerMinPrincipal(mercuryPublicKeyCert),
                                                          new ServerMinPrincipal(outriggerPublicKeyCert)
                                                        };
    private proxyConstraints
         = new BasicMethodConstraints( new InvocationConstraints
                                           ( new InvocationConstraint[]{ Integrity.YES,
                                                                         ClientAuthentication.YES,
                                                                         ServerAuthentication.YES,
                                                                         new ConstraintAlternatives(proxyPrincipals)
                                                                       },
                                             null)
                                     );

    /* Create the proxy preparer that should be used to prepare each proxy
     * with which the Browser interacts. Each preparer should verify trust
     * in the proxy using the constraints specified above. And it should
     * grant to each proxy the following permission(s):
     *
     * When requesting a connection to a proxy's backend implementation,
     * (running in some remote VM), that authenticates as at lease one of
     * the principals listed above, the preparer dynamically grants to the
     * proxy, permission to authenticate as no more than the Browser's
     * principal. Although the affected proxy is allowed to make outbound
     * calls ("connect") under the conditions just stated, it is not
     * allowed to accept incoming calls, nor would delegation be allowed if
     * that proxy was allowed to actually make outbound calls.
     */
    adminPreparer = new BasicProxyPreparer( true,
                                            proxyConstraints,
                                            new Permission[] { new AuthenticationPermission(clientPublicKeyCert,
                                                                                            servicePublicKeys,
                                                                                            "connect")
                                                             }
                                          );

    leasePreparer = new BasicProxyPreparer( true,
                                            proxyConstraints,
                                            new Permission[] { new AuthenticationPermission(clientPublicKeyCert,
                                                                                            reggiePublicKeyCert,
                                                                                            "connect")
                                                             }
                                          );

    servicePreparer = new BasicProxyPreparer( true,
                                            proxyConstraints,
                                            new Permission[] { new AuthenticationPermission(clientPublicKeyCert,
                                                                                            servicePublicKeys,
                                                                                            "connect")
                                                             }
                                            );

    /* JAAS Login --------------------------------------------------------------- */

    /* For every object in the Browser's VM that must perform a JAAS
     * login, the JAAS login configuration should contain an entry that
     * identifies the following information used in the login process:
     *  - the keystore from which to retrieve the private key used to login
     *  - the alias of the private key to retrieve
     *  - the (optional) location of the password file(s) from which to retrieve
     *    the appropriate password(s) needed to retrieve the private key information
     *
     * The item below identifies the entry to use, from the JAAS login
     * configuration file for this Browser's VM, when an object in that
     * VM performs a JAAS login.
     */
    loginContext = new LoginContext("client.jaas.login");

    /* Application-specific Items ----------------------------------------------- */

    initialLookupGroups = new String[] {"JSSE_Group0","JSSE_Group1"};
//    initialLookupGroups   = new String[] {""};
//    initialLookupLocators = new LookupLocator[] { new LookupLocator("jini://${serverHost}")};

}//end com.sun.jini.example.browser

/* Because this Browser is a well-behaved Jini client, it
 * obtains proxies to any discovered lookup services it might
 * query. The interaction with those lookup service(s), through
 * those proxies, generally occurs through the use of a helper
 * utility such as a lookup discovery utility or a lookup locator
 * discovery utility. Each such proxy must be prepared by a proxy
 * preparer retrieved from this configuration file.
 *
 * The proxies for which preparers must be provided by this file are
 * as follows:
 *  - proxy to any discovered lookup service received by the lookup
 *    discovery utility
 *  - proxy to any discovered lookup service received by the lookup
 *    locator discovery utility
 *
 * All of the above preparers share the following constraints:
 *  - integrity of the call (verify no one corrupts the call)
 *  - client authentication (the 'client' [the Browser] that makes
 *    calls through the lookup service proxy must tell the 'server'
 *    [the lookup service] who it is)
 *  - server authentication (the 'client' [the Browser] requires the
 *    lookup service to identify itself to the 'client')
 *  - when performing server athentication, the 'server' [the lookup
 *    service] must authenticate as at least the given principal
 *    ("reggie")
 *
 * This block contains private entries that are shared by the entries
 * defined below in the blocks corresponding to the discovery utilities
 * and the Browser.
 */
shared.entries {

    private browserLookupConstraints
         = new BasicMethodConstraints( new InvocationConstraints
                                           ( new InvocationConstraint[]{ Integrity.YES,
                                                                         ClientAuthentication.YES,
                                                                         ServerAuthentication.YES,
                                                                         new ServerMinPrincipal(com.sun.jini.example.browser.reggiePublicKeyCert)
                                                                       },
                                             null)
                                     );
}//end shared.entries

/* Configuration block for the lookup discovery utility */
net.jini.discovery.LookupDiscovery {

    /* Preparer for the lookup service proxy used by the
     * lookup discovery utility. 
     *  - verify trust with the given constraints attached
     *  - if the lookup service's backend authenticates as
     *    "reggie", then dynamically grant to that lookup
     *    service's proxy, permission to authenticate as
     *    the principal of the given service
     */
    registrarPreparer = new BasicProxyPreparer( true,
                                                shared.entries.browserLookupConstraints,
                                                new Permission[] { new AuthenticationPermission(com.sun.jini.example.browser.clientPublicKeyCert,
                                                                                                com.sun.jini.example.browser.reggiePublicKeyCert,
                                                                                                "connect")
                                                                 }
                                              );

}//end net.jini.discovery.LookupDiscovery
