# Begin -- grammar generated by Yapps
import sys, re
import yapps.yappsrt as yappsrt

class lindaScanner(yappsrt.Scanner):
    patterns = [
        ("'route'", re.compile('route')),
        ('\\s+', re.compile('\\s+')),
        ('END', re.compile('$')),
        ('INT', re.compile('-?[1-9][0-9]*')),
        ('FLOAT', re.compile('-?[1-9][0-9]*[.][0-9]+')),
        ('STRING', re.compile('["][a-zA-Z.\';:#~!\xa3$%^&*()]+["]')),
        ('TYPE', re.compile('int|float|str|TS')),
        ('TSID', re.compile('S[0-9a-zA-Z]+|UTS|uts')),
        ('LIST', re.compile('list')),
        ('INSPECT', re.compile('inspect')),
        ('INP', re.compile('inp')),
        ('RDP', re.compile('rdp')),
        ('IN', re.compile('in')),
        ('RD', re.compile('rd')),
        ('OUT', re.compile('out')),
        ('COLLECT', re.compile('collect')),
        ('COPYCOLLECT', re.compile('copy collect')),
        ('VAR', re.compile('[a-zA-Z]+')),
        ('PLUS', re.compile('[+]')),
        ('SUB', re.compile('[-]')),
        ('MUL', re.compile('[*]')),
        ('DIV', re.compile('[/]')),
        ('COMMA', re.compile('[,]')),
        ('OPENB', re.compile('[(]')),
        ('CLOSEB', re.compile('[)]')),
        ('EQUAL', re.compile('=')),
        ('USCORE', re.compile('_')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,['\\s+'],str)

class linda(yappsrt.Parser):
    Context = yappsrt.Context
    def goal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'goal', [])
        command = self.command(_context)
        END = self._scan('END')
        return command

    def command(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'command', [])
        _token = self._peek("'route'", 'LIST', 'INSPECT', 'OUT', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE')
        if _token == 'LIST':
            list = self.list(_context)
            return list
        elif _token == 'INSPECT':
            inspect = self.inspect(_context)
            return inspect
        elif _token == "'route'":
            self._scan("'route'")
            return ("route", )
        elif _token == 'OUT':
            out = self.out(_context)
            return out
        else:
            expr = self.expr(_context)
            return ("expr", expr)

    def name(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'name', [])
        _token = self._peek('TSID', 'VAR')
        if _token == 'TSID':
            TSID = self._scan('TSID')
            return ("tsid", TSID)
        else: # == 'VAR'
            VAR = self._scan('VAR')
            return ("var", str(VAR))

    def list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'list', [])
        LIST = self._scan('LIST')
        return ("list", )

    def inspect(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'inspect', [])
        INSPECT = self._scan('INSPECT')
        name = self.name(_context)
        return ("inspect", name)

    def _in(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, '_in', [])
        IN = self._scan('IN')
        expr = self.expr(_context)
        v1, v2 = expr, None
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v2 = expr
        return ("in", v1, v2)

    def rd(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'rd', [])
        RD = self._scan('RD')
        expr = self.expr(_context)
        v1, v2 = expr, None
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v2 = expr
        return ("rd", v1, v2)

    def _inp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, '_inp', [])
        INP = self._scan('INP')
        expr = self.expr(_context)
        v1, v2 = expr, None
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v2 = expr
        return ("inp", v1, v2)

    def rdp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'rdp', [])
        RDP = self._scan('RDP')
        expr = self.expr(_context)
        v1, v2 = expr, None
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v2 = expr
        return ("rdp", v1, v2)

    def out(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'out', [])
        OUT = self._scan('OUT')
        expr = self.expr(_context)
        v1, v2 = expr, None
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'END', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') != 'END':
            expr = self.expr(_context)
            v2 = expr
        return ("out", v1, v2)

    def collect(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'collect', [])
        COLLECT = self._scan('COLLECT')
        expr = self.expr(_context)
        v1, v2, v3 = expr, None, None
        expr = self.expr(_context)
        v2 = expr
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v3 = expr
        return ("collect", v1, v2, v3)

    def copycollect(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'copycollect', [])
        COPYCOLLECT = self._scan('COPYCOLLECT')
        expr = self.expr(_context)
        v1, v2, v3 = expr, None, None
        expr = self.expr(_context)
        v2 = expr
        if self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA') not in ['CLOSEB', 'EQUAL', 'END', 'PLUS', 'SUB', 'COMMA']:
            expr = self.expr(_context)
            v3 = expr
        return ("copy collect", v1, v2, v3)

    def expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'expr', [])
        bracket = self.bracket(_context)
        v = bracket
        if self._peek('EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'COMMA', 'CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') == 'EQUAL':
            EQUAL = self._scan('EQUAL')
            expr = self.expr(_context)
            v = ("assign", v, expr)
        return v

    def bracket(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'bracket', [])
        _token = self._peek('OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE')
        if _token == 'OPENB':
            OPENB = self._scan('OPENB')
            linda = self.linda(_context)
            CLOSEB = self._scan('CLOSEB')
            return linda
        else:
            linda = self.linda(_context)
            return linda

    def linda(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'linda', [])
        _token = self._peek('IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE')
        if _token == 'IN':
            _in = self._in(_context)
            return _in
        elif _token == 'RD':
            rd = self.rd(_context)
            return rd
        elif _token == 'INP':
            _inp = self._inp(_context)
            return _inp
        elif _token == 'RDP':
            rdp = self.rdp(_context)
            return rdp
        elif _token == 'COLLECT':
            collect = self.collect(_context)
            return collect
        elif _token == 'COPYCOLLECT':
            copycollect = self.copycollect(_context)
            return copycollect
        else: # in ['INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']
            tuple = self.tuple(_context)
            return tuple

    def tuple(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'tuple', [])
        sum = self.sum(_context)
        v = sum
        if self._peek('COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') == 'COMMA':
            COMMA = self._scan('COMMA')
            v = ("tuple", (v, ))
            if self._peek('COMMA', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT') in ['INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']:
                sum = self.sum(_context)
                v = ("tuple", v[1] + (sum, ))
                while self._peek('COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') == 'COMMA':
                    COMMA = self._scan('COMMA')
                    sum = self.sum(_context)
                    v = ("tuple", v[1] + (sum, ))
                if self._peek() not in ['COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']:
                    raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'PLUS', 'SUB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']))
        return v

    def sum(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'sum', [])
        factor = self.factor(_context)
        v = factor
        while self._peek('PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') in ['PLUS', 'SUB']:
            _token = self._peek('PLUS', 'SUB')
            if _token == 'PLUS':
                PLUS = self._scan('PLUS')
                expr = self.expr(_context)
                v = ("+", v, expr)
            else: # == 'SUB'
                SUB = self._scan('SUB')
                expr = self.expr(_context)
                v = ("-", v, expr)
        if self._peek() not in ['PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']))
        return v

    def factor(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'factor', [])
        funccall = self.funccall(_context)
        v = funccall
        while self._peek('MUL', 'DIV', 'PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') in ['MUL', 'DIV']:
            _token = self._peek('MUL', 'DIV')
            if _token == 'MUL':
                MUL = self._scan('MUL')
                factor = self.factor(_context)
                v = ("*", v, factor)
            else: # == 'DIV'
                DIV = self._scan('DIV')
                factor = self.factor(_context)
                v = ("/", v, factor)
        if self._peek() not in ['MUL', 'DIV', 'PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['MUL', 'DIV', 'PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'OPENB', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE']))
        return v

    def funccall(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'funccall', [])
        single_expr = self.single_expr(_context)
        v = single_expr
        if self._peek('OPENB', 'MUL', 'DIV', 'PLUS', 'SUB', 'COMMA', 'CLOSEB', 'EQUAL', 'END', 'IN', 'RD', 'INP', 'RDP', 'COLLECT', 'COPYCOLLECT', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') == 'OPENB':
            OPENB = self._scan('OPENB')
            args = ("tuple", ())
            if self._peek('CLOSEB', 'INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE') != 'CLOSEB':
                tuple = self.tuple(_context)
                args = tuple
            CLOSEB = self._scan('CLOSEB')
            v = ("funccall", v, args)
        return v

    def single_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'single_expr', [])
        _token = self._peek('INT', 'FLOAT', 'STRING', 'TSID', 'VAR', 'USCORE')
        if _token == 'INT':
            INT = self._scan('INT')
            return ("val", int(INT))
        elif _token == 'FLOAT':
            FLOAT = self._scan('FLOAT')
            return ("val", float(FLOAT))
        elif _token == 'STRING':
            STRING = self._scan('STRING')
            return ("val", eval(STRING))
        elif _token != 'USCORE':
            name = self.name(_context)
            return name
        else: # == 'USCORE'
            USCORE = self._scan('USCORE')
            return ("skip", )


def parse(rule, text):
    P = linda(lindaScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
